import time
import threading
# Изучаем синхронизацию потоков и возможность блокировки.

value = 0
# Задаем блокировщик
locker = threading.Lock()

# Если запустить код без блокировки, потоки будут выводить результат без синхронизации. Все потоки
# одновременно могут обратиться к переменной value  и изменить ее.
# С блокировкой вывод работает правильно: 1 2 3 4 5 6 ... Только один поток может работать
# с переменной одномоментно.
def inc_value():
    global value

    while True:
        # Блокируем следующие строки кода. Другие потоки не смогут его выполнить,
        # пока первый поток не завершит выполнение кода.
        #locker.acquire()
        with locker:
            value += 1
            time.sleep(1)
            print(value)
        # Снимаем блокировку. Следующий поток может приступить к работе.
        #locker.release()
        # Можно использовать locker.acquire(), чтобы запустить блокировку и
        # locker.release(), чтобы ее снять.
        # with locker: - более короткая форма записи.
        # Блокировку можно заблокировать/разблокировать из любого потока.
        # Сравнение: Есть замок, но ключ к нему есть у каждого.

        # Чтобы такого избежать можно использовать locker = threading.RLock()
        # В таком случае блокировку может разблокировать только тот поток,
        #          который его заблокировал.
        # Сравнение: Есть замок, ключ от него только у одного человека.
for i in range(5):
    threading.Thread(target=inc_value,name=f"thread-{i}").start()